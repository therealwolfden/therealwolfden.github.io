<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang=“en-US”>
    <head>
        <meta charset="UTF-8" />
        <base href="https://therealwolfden.github.io/">
        <link href="/style/wolf-den.css" rel="stylesheet" type="text/css" />
        <link href="/style/course.css" rel="stylesheet" type="text/css" />
        <link rel="icon" href="/assets/page-icon.jpg" type="image/icon type">
        <title>Priority Queue ADT</title>
        <script src="/js/jquery-3.6.0.min.js"></script>
        <script src="/js/scripts.js"></script>
    </head>
    <body style="background-color:#ffffff">
      <!-- Creates the top portion of the page that follows the screen and has all the important controls -->
      <div style="height: 40px;"></div>
        <div class="fixed"><div class="navbar">

          <!-- The Home Button -->
          <a href="/index.html" style="margin-left: 10px;"><img src="/assets/home-icon.jpg" alt="Home Icon" class="icon"></a>

          <!-- The Events Button that takes the user to the events page -->
          <a href="/html/events/events.html">Events</a>

          <!-- The Class Guides Button that toggles a drop down menu with links to various class pages -->
          <div class="dropdown" id="guides">
            <button class="dropbtn">Class Guides
              <i class="fa fa-caret-down"></i>
            </button>

            <!-- The drop down menu for the Class Guides -->
            <div class="dropdown-content">
              <a href="/html/classes/csc-316/csc-316.html">CSC 316 (Data Structures and Algorithms)</a>
              <a href="/html/classes/mae-302/mae-302.html">MAE 302 (Engineering Thermodynamics II)</a>
              <a href="/html/classes/mae-308/mae-308.html">MAE 308 (Fluid Mechanics)</a>
              <a href="/html/classes/mae-310/mae-310.html">MAE 310 (Heat Transfer Fundamentals)</a>
              <a href="/html/classes/mae-315/mae-315.html">MAE 315 (Dynamics of Machines)</a>
            </div>
          </div>

          <!-- The Organizations Button that takes the user to the organizations page -->
          <a href="/html/organizations/organizations.html">Organizations</a>

          <!-- The Brain Teasers Button that takes the user to the brain teasers page -->
          <a href="/html/brain_teasers/brain_teasers.html">Brain Teasers</a>

          <!-- The Forums Button that takes the user to the forums page -->
          <a href="/html/forums/forums.html">Forums</a>

          <!-- The Profile Button that toggles a drop down menu for logging out and other options -->
          <a href="/html/forums/forums.html" style="float: right; margin-right: 10px;" style="margin-right: 10px;">Profile</a>

          <!-- The Calendar Button that takes the user to their calendar -->
          <a href="/html/calendar/calendar.html" style="float: right;"><img src="/assets/calendar-icon.jpg" alt="Calendar Icon" class="icon"></a>

          <!-- The Notifications Button that toggles a drop down menu with recent notifications -->
          <a href="/html/notifications/notifications.html" style="float: right;"><img src="/assets/notification-icon.jpg" alt="Notification Icon" class="icon"></a>

          <!-- The Search Button that opens a menu for searching through the website -->
          <a href="" style="float: right;"><img src="/assets/search-icon.jpg" alt="Search Icon" class="icon"></a>
        </div>
      </div>

      <div class="course-info-box">
        <div style="float: left;"><strong>CSC 316 | Data Structures and Algorithms: </strong></div>
        <div style="float: right;"><strong>J. King</strong></div>
        <br>
        <br>
        <em>Abstract data types; abstract and implementation-level views of data types. Linear and branching data structures, including stacks, queues,
          trees, heaps, hash tables, graphs, and others at discretion of instructor. Best, worst, and average case asymptotic time and space complexity
          as a means of formal analysis of iterative and recursive algorithms.</em>
      </div>

      <!-- Header for the page -->
      <div class="sticky">
        <div id="head" class="class-navbar">

          <!-- Class Name -->
          <a href="/html/classes/csc-316/csc-316.html"><strong><em>Data Structures and Algorithms</em></strong></a>

          <!-- Class Content (Lectures and Units) -->
          <div class="class-dropdown" id="content">
            <button class="class-dropbtn"><em>Units</em>
              <i class="fa fa-caret-down"></i>
            </button>

            <!-- The drop down menu for the Class Guides -->
            <div class="class-dropdown-content">
              <a href="/html/classes/csc-316/unit1/unit1.html"><em>Problems, Algorithms, and Programs</em></a>
              <a href="/html/classes/csc-316/unit2/unit2.html"><em>Growth Rates</em></a>
              <a href="/html/classes/csc-316/unit3/unit3.html"><em>Algorithm Analysis and Iterative Sorting Algorithms</em></a>
              <a href="/html/classes/csc-316/unit4/unit4.html"><em>List and Positional List ADTs</em></a>
              <a href="/html/classes/csc-316/unit5/unit5.html"><em>Stack and Queue ADTs</em></a>
              <a href="/html/classes/csc-316/unit6/unit6.html"><em>Recursive Algorithm Analysis</em></a>
              <a href="/html/classes/csc-316/unit7/unit7.html"><em>Recursive Comparison-based Sorting Algorithms</em></a>
              <a href="/html/classes/csc-316/unit8/unit8.html"><em>Map ADT</em></a>
              <a href="/html/classes/csc-316/unit9/unit9.html"><em>Tree ADT</em></a>
              <a href="/html/classes/csc-316/unit10/unit10.html"><em>Binary Search Trees and Balancable Trees</em></a>
              <a href="/html/classes/csc-316/unit11/unit11.html"><em>AVL Trees</em></a>
              <a href="/html/classes/csc-316/unit12/unit12.html"><em>Splay Trees</em></a>
              <a href="/html/classes/csc-316/unit13/unit13.html"><em>Multiway Search Trees: (2, 4) Trees</em></a>
              <a href="/html/classes/csc-316/unit14/unit14.html"><em>Red-Black Trees</em></a>
              <a href="/html/classes/csc-316/unit15/unit15.html"><em>Hash Tables: Hash Functions</em></a>
              <a href="/html/classes/csc-316/unit16/unit16.html"><em>Hash Tables: Collision Resolution</em></a>
              <a href="/html/classes/csc-316/unit17/unit17.html"><em>Priority Queue ADT</em></a>
              <a href="/html/classes/csc-316/unit18/unit18.html"><em>Set and Disjoint Set ADTs</em></a>
              <a href="/html/classes/csc-316/unit19/unit19.html"><em>Graph Abstract Data Type</em></a>
              <a href="/html/classes/csc-316/unit20/unit20.html"><em>Graph Traversals</em></a>
              <a href="/html/classes/csc-316/unit21/unit21.html"><em>Transitive Closure and All-Pairs Shortest Paths Algorithm</em></a>
              <a href="/html/classes/csc-316/unit22/unit22.html"><em>Single-Source Shortest Paths and Minimum Spanning Tree Algorithms</em></a>
              <a href="/html/classes/csc-316/unit23/unit23.html"><em>Graph Applications</em></a>
              <a href="/html/classes/csc-316/unit24/unit24.html"><em>Complexity Theory; Data Structures in the Java Libraries</em></a>
              <a href="/html/classes/csc-316/unit25/unit25.html"><em>Secret Rules of Modern Living: Algorithms</em></a>
            </div>
          </div>

          <!-- Formulas -->
          <a href="/html/classes/csc-316/formulas/formulas.html"><em>Formulas</em></a>

          <!-- Tables -->
          <a href="/html/classes/csc-316/tables/tables.html"><em>Tables</em></a>

          <!-- Pseudocode -->
          <a href="/html/classes/csc-316/pseudocode/pseudocode.html"><em>Pseudocode</em></a>

          <!-- Grade Calculator -->
          <a href="/html/classes/csc-316/grade-calculator/grade-calculator.html"><em>Grade Calculator</em></a>
        </div>
      </div>
      <br>

      <div class="body">
        <em></em>

        <!-- Section 17 -->
        <div class="sect-box">
          <h2><center>Priority Queue ADT</center></h2>
          <hr>

          <!-- Priority Queue ADT -->
          <h3><em>Priority Queue ADT</em></h3>
          <span class="tab"></span><strong><em>Priority Systems</em></strong> serve entries based on their priority.
          <ul>
            <li><strong>Priority</strong> is represented as a key assigned to each entry.</li>
            <li>Entry of the highest priority is served first.</li>
            <li>Various applications including...</li>
            <ul>
              <li>Hospital emergeny rooms.</li>
              <li>Fly standby, boarding zones.</li>
              <li>Packet routers (traffic control).</li>
              <li>Scheduling based on deadline.</li>
            </ul>
          </ul>
          <br>

          <span class="tab"></span><strong><em>Priority Queue ADT:</em></strong>
          <ul>
            <li>Stores entries and their priority represented as key-values.</li>
            <li>Keys determine the priority used to pick entries to be dequeued.</li>
            <li>Keys may be idential (same priority level).</li>
            <li>In general, a priority queue should implement operations for...</li>
            <ul>
              <li>insert(k,v) where the value <em>v</em> is inserted into the queue with priority <em>k</em>.</li>
              <li>min() where the item with the lowest priority is returned but not removed.</li>
              <li>deleteMin() where the item with the lowest priority is returned and removed.</li>
            </ul>
          </ul>
          <br>

          <!-- Priority Queue Sorting -->
          <h3><em>Priority Queue Sorting</em></h3>
          <span class="tab"></span><strong><em>Sorting:</em></strong>
          <ul>
            <li>PQ-Sort uses priority queue to sort a set of n elements</li>
            <ul>
              <li>Insert the elements one-by-one requiring n insert operations</li>
              <li>Remove the elements in sorted order requiring n deleteMin operations</li>
            </ul>
          </ul>
          <div class="question-box">
            <strong>Algorithm PQ-Sort(L, C)</strong><br>
            <span class="tab"></span><strong>Input</strong> a list L of n entries<br>
            <span class="tab"></span><strong>Output</strong> list L sorted in with keys sorted in increasing order<br>
            <span class="tab"></span>P &larr; a new empty priority queue<br>
            <span class="tab"></span>while NOT L.isEmpty() do<br>
            <span class="tab"></span><span class="tab"></span>e &larr; L.removeFirst()<br>
            <span class="tab"></span><span class="tab"></span>P.insert(e.key, e)<br>
            <span class="tab"></span>while NOT P.isEmpty() do<br>
            <span class="tab"></span><span class="tab"></span>e &larr; P.deleteMin()<br>
            <span class="tab"></span><span class="tab"></span>L.addLast(e)<br>
          </div>
          <br>

          <span class="tab"></span><strong><em>Implementations:</em></strong>
          <ul>
            <li>Unsorted List Implementation</li>
            <ul>
              <li>Fast insertions as the value is just added at the front.</li>
              <li>Slow removals as the entire list must be traversed.</li>
              <li>Selection sort runs in O(n<sup>2</sup>).</li>
            </ul>
            <li>Sorted List Implementation</li>
            <ul>
              <li>Slow insertions as the entire list must be traversed.</li>
              <li>Fast removal as the smallest key is at the front.</li>
              <li>Insertion sort runs in O(n<sup>2</sup>).</li>
            </ul>
            <li>Balanced trees</li>
            <ul>
              <li>Allows for more efficent insert and delete.</li>
              <li>Should use a seperate data structure called a <em>heap</em>.</li>
            </ul>
          </ul>
          <br>

          <!-- Heaps -->
          <h3><em>Heaps</em></h3>
          <span class="tab"></span><strong><em>Heap Data Structure:</em></strong>
          <ul>
            <li>A heap is a binary tree that satisfies two properties.</li>
            <li>Partial Order Property:</li>
            <ul>
              <li>Min-Heap: for each node <em>v</em> with parent <em>w</em>, key(v) ≥ key(w) making the minimum value the root.</li>
              <li>Max-Heap: for each node <em>v</em> with parent <em>w</em>, key(v) ≤ key(w) making the maximum value the root.</li>
            </ul>
            <li>Complete Binary Tree Property:</li>
            <ul>
              <li>For a tree with height <em>h</em>, levels 0 to h-1 have the max possible amount of nodes and all leaves are children of
                the leftmost node.</li>
            </ul>
            <li>It does not matter if the left child is greater than the right child.</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>Heap Height:</em></strong>
          <ul>
            <li>Minimum possible nodes given height h is equal to 2<sup>h</sup> nodes.</li>
            <li>Maximum possible nodes given height h is equal to 2<sup>h+1</sup> - 1 nodes.</li>
            <li>Heap height is O(log(n)).</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>deleteMin Operation:</em></strong>
          <ul>
            <li>w is the bottom most, right-most leaf node.</li>
            <li>k is the key of w.</li>
            <li>Steps:</li>
            <ol>
              <li>key(root) &larr; k, remove w.</li>
              <li>Swap key k with its smallest child.</li>
              <li>Repeat step 2 until heap-order property is restored (downHeap).</li>
            </ol>
            <li>Runs in O(log(n)) runtime.</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>insert Operation:</em></strong>
          <ul>
            <li>Steps:</li>
            <ol>
              <li>Insert key <em>k</em> as the new bottom-most, right-most leaf node <em>w</em>.</li>
              <li>If k < key(parent(w)) then swap k with its parent key.</li>
              <li>Repeat Step 2 until heap-order property is restored (upHeap).</li>
            </ol>
            <li>Runs in O(log(n)) runtime.</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>Heap Sort:</em></strong>
          <ul>
            <li>Variation of PQ-sort with a heap as the implementation for the Priority Queue.</li>
            <li>Insert runs in O(nlog(n))</li>
            <li>Remove runs in O(nlog(n))</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>Array Based Heap Implementation:</em></strong>
          <ul>
            <li>The position of the value determines what it is classified as.</li>
            <ul>
              <li>1, v is the root.</li>
              <li>2 * pos(parent(v)), v is the left child.</li>
              <li>2 * pos(parent(v)) + 1, v is the right child.</li>
            </ul>
            <li>No links between nodes are explicitly stored.</li>
            <li>If the heap has n nodes, insert at position n and remove at position n-1.</li>
            <li>The array should just look like a level-order traversal with no gaps.</li>
          </ul>
          <div class="question-box">
            <strong>Algorithm insert(key k, element x, list L)</strong><br>
            <span class="tab"></span><strong>Input</strong> a key k for an element x to insert into an arraylist L with n elements<br>
            <span class="tab"></span>e &larr; new PQEntry(k, x)<br>
            <span class="tab"></span>L.addLast(e)<br>
            <span class="tab"></span>upHeap(L, L.size()-1)<br>
            <span class="tab"></span>return e<br>
          </div>
          <br>

          <div class="question-box">
            <strong>Algorithm upHeap(arraylist L, integer i)</strong><br>
            <span class="tab"></span><strong>Input</strong> the index i of the entry in the arraylist L<br>
            <span class="tab"></span>if i > 0 then<br>
            <span class="tab"></span><span class="tab"></span>parentIndex &larr; (i-1)/2<br>
            <span class="tab"></span><span class="tab"></span>if key( L.get(parentIndex) ) > key( L.get(i) ) then<br>
            <span class="tab"></span><span class="tab"></span><span class="tab"></span>L.swap(parentIndex, i)<br>
            <span class="tab"></span><span class="tab"></span><span class="tab"></span>upHeap(L, parentIndex)<br>
          </div>
          <br>

          <div class="question-box">
            <strong>Algorithm deleteMin(arraylist L)</strong><br>
            <span class="tab"></span><strong>Input</strong> an arraylist L with n entries<br>
            <span class="tab"></span><strong>Output</strong> the minimum entry in the heap<br>
            <span class="tab"></span>if L.isEmpty() then<br>
            <span class="tab"></span><span class="tab"></span>return “empty heap”<br>
            <span class="tab"></span>temp &larr; L.first()<br>
            <span class="tab"></span>L.swap(0, L.size()-1 )<br>
            <span class="tab"></span>L.removeLast()<br>
            <span class="tab"></span>downHeap(L, 0)<br>
            <span class="tab"></span>return temp<br>
          </div>
          <br>

          <div class="question-box">
            <strong>Algorithm downHeap(arraylist L, integer i)</strong><br>
            <span class="tab"></span><strong>Input</strong> an arraylist L with n entries, index i being downheaped<br>
            <span class="tab"></span>leftIndex &larr; 2*i + 1<br>
            <span class="tab"></span>rightIndex &larr; 2*i + 2<br>
            <span class="tab"></span>if leftIndex >= L.size() then<br>
            <span class="tab"></span><span class="tab"></span>return “already a leaf, no more downheaps needed”<br>
            <span class="tab"></span>smallestChildIndex &larr; leftIndex<br>
            <span class="tab"></span>if rightIndex < L.size() AND key( L.get(rightIndex) ) < key( L.get(leftIndex) ) then<br>
            <span class="tab"></span><span class="tab"></span>smallestChildIndex &larr; rightIndex<br>
            <span class="tab"></span>if key( L.get(smallestChildIndex) ) >= key( L.get(i) ) then<br>
            <span class="tab"></span><span class="tab"></span>return “no downheaps needed”<br>
            <span class="tab"></span>L.swap( smallestChildIndex, i)<br>
            <span class="tab"></span>downHeap( L, smallestChildIndex)<br>
          </div>
          <br>

          <!-- Adaptable Priority Queues -->
          <h3><em>Adaptable Priority Queues</em></h3>
          <span class="tab"></span><strong><em>Traditional Priority Queues</em></strong> do not support
          <ul>
            <li>Changing arbitrary keys, values.</li>
            <li>Removing arbitrary keys, values.</li>
            <li>The solution is an Adaptable Priority Queue that allows the manipulation of arbitrary values.</li>
          </ul>
          <br>

          <span class="tab"></span><strong><em>Adaptable Priority Queues</em></strong>
          <ul>
            <li>Additional methods are implemented including...</li>
            <ul>
              <li>remove(e) which removes and returns entry <em>e</em> from the priority queue.</li>
              <li>replaceKey(e, k) which replaces the key of existing entry <em>e</em>.</li>
              <li>replaceValue(e, v) which replaces the value of the existing entry <em>e</em>.</li>
            </ul>
            <li>For the most efficent implementation, make entries location-aware.</li>
            <ul>
              <li>remove(e) is O(log(n)).</li>
              <li>replaceKey(e, k) is O(log(n)).</li>
              <li>replaceValue(e, v) is O(1).</li>
            </ul>
            <li>A bubbling algorithm can help determine whether to upHeap or downHeap.</li>
          </ul>
          <div class="question-box">
            <strong>Algorithm bubble(L, i)</strong><br>
            <span class="tab"></span><strong>Input</strong> an arraylist L, an index i<br>
            <span class="tab"></span><strong>Output</strong> the minheap after restoring partial order property<br>
            <span class="tab"></span>parentIndex &larr; (i-1)/2<br>
            <span class="tab"></span>if key( L.get(i) ) < key( L.get(parentIndex) ) then<br>
            <span class="tab"></span><span class="tab"></span>upHeap(L, i)<br>
            <span class="tab"></span>else<br>
            <span class="tab"></span><span class="tab"></span>downHeap(L, i)<br>
          </div>
          <br>

        </div>
      </div>
    </body>

    <script type="text/javascript">
      function showAnswer(id, but, ans, ans2, ans3, ans4, ans5, ans6, ans7, ans8, ans9, ans10) {
        var x = document.getElementById(id);
        var y = document.getElementById(but);
        var varAns = document.getElementById(ans);
        var varAns2 = document.getElementById(ans2);
        var varAns3 = document.getElementById(ans3);
        var varAns4 = document.getElementById(ans4);
        var varAns5 = document.getElementById(ans5);
        var varAns6 = document.getElementById(ans6);
        var varAns7 = document.getElementById(ans7);
        var varAns8 = document.getElementById(ans8);
        var varAns9 = document.getElementById(ans9);
        var varAns10 = document.getElementById(ans10);
        if (x.style.display === "none") {
          x.style.display = "block";
          y.innerHTML = 'Hide Answer';
        }
        else {
          x.style.display = "none";
          y.innerHTML = 'Show Answer';
        }
        if (varAns.classList.contains("correct")) {
          varAns.classList.remove("correct")
          varAns2.classList.remove("correct")
          varAns3.classList.remove("correct")
          varAns4.classList.remove("correct")
          varAns5.classList.remove("correct")
          varAns6.classList.remove("correct")
          varAns7.classList.remove("correct")
          varAns8.classList.remove("correct")
          varAns9.classList.remove("correct")
          varAns10.classList.remove("correct")
        }
        else {
          varAns.classList.add("correct")
          varAns2.classList.add("correct")
          varAns3.classList.add("correct")
          varAns4.classList.add("correct")
          varAns5.classList.add("correct")
          varAns6.classList.add("correct")
          varAns7.classList.add("correct")
          varAns8.classList.add("correct")
          varAns9.classList.add("correct")
          varAns10.classList.add("correct")
        }
        varAns.classList.add("correct")
      }
      function selectMultAns(id) {
        var x = document.getElementById(id);
        if (x.classList.contains("answer-choice")) {
          x.classList.replace("answer-choice", "answer-choice-selected")
        }
        else {
          x.classList.replace("answer-choice-selected", "answer-choice")
        }
      }

      function selectAns(id, id2, id3, id4, id5, id6, id7, id8, id9, id10) {
        var x = document.getElementById(id);
        var x2 = document.getElementById(id2);
        var x3 = document.getElementById(id3);
        var x4 = document.getElementById(id4);
        var x5 = document.getElementById(id5);
        var x6 = document.getElementById(id6);
        var x7 = document.getElementById(id7);
        var x8 = document.getElementById(id8);
        var x9 = document.getElementById(id9);
        var x10 = document.getElementById(id10);
        if (x.classList.contains("answer-choice")) {
          x.classList.replace("answer-choice", "answer-choice-selected")
          x2.classList.replace("answer-choice-selected", "answer-choice")
          x3.classList.replace("answer-choice-selected", "answer-choice")
          x4.classList.replace("answer-choice-selected", "answer-choice")
          x5.classList.replace("answer-choice-selected", "answer-choice")
          x6.classList.replace("answer-choice-selected", "answer-choice")
          x7.classList.replace("answer-choice-selected", "answer-choice")
          x8.classList.replace("answer-choice-selected", "answer-choice")
          x9.classList.replace("answer-choice-selected", "answer-choice")
          x10.classList.replace("answer-choice-selected", "answer-choice")
        }
        else {
          x.classList.replace("answer-choice-selected", "answer-choice")
        }
      }
    </script>
</html>
